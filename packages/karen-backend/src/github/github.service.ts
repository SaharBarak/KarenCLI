import { Injectable } from '@nestjs/common';
import { Octokit } from '@octokit/rest';
import { type ServiceResult, ok, err, ServiceError, resultify } from '../common/result';

export interface PullRequestParams {
  repoUrl: string;
  accessToken: string;
  issues: any[];
}

@Injectable()
export class GithubService {
  async createPullRequest(params: PullRequestParams): Promise<ServiceResult<string>> {
    return resultify(
      async () => {
        const octokit = new Octokit({ auth: params.accessToken });
        const [owner, repo] = this.parseRepoUrl(params.repoUrl);

        // Get main branch SHA
        const { data: mainBranch } = await octokit.repos.getBranch({
          owner,
          repo,
          branch: 'main',
        });

        const mainSha = mainBranch.commit.sha;

        // Create new branch
        const branchName = `karen-fixes-${Date.now()}`;
        await octokit.git.createRef({
          owner,
          repo,
          ref: `refs/heads/${branchName}`,
          sha: mainSha,
        });

        // Group issues by file
        const fileChanges = this.groupIssuesByFile(params.issues);

        // Apply fixes to files
        for (const [filePath, fileIssues] of Object.entries(fileChanges)) {
          await this.applyFixesToFile(octokit, owner, repo, branchName, filePath, fileIssues);
        }

        // Create PR
        const prBody = this.buildPRDescription(params.issues);
        const { data: pr } = await octokit.pulls.create({
          owner,
          repo,
          title: `ðŸ”§ Karen found ${params.issues.length} layout issues`,
          head: branchName,
          base: 'main',
          body: prBody,
        });

        return pr.html_url;
      },
      (error) => ServiceError.githubError('Failed to create pull request', error)
    );
  }

  private parseRepoUrl(repoUrl: string): [string, string] {
    const match = repoUrl.match(/github\.com[\/:]([^\/]+)\/([^\/\.]+)/);
    if (!match) throw new Error('Invalid GitHub URL');
    return [match[1], match[2]];
  }

  private groupIssuesByFile(issues: any[]): Record<string, any[]> {
    const grouped: Record<string, any[]> = {};

    for (const issue of issues) {
      if (issue.fix?.code?.file) {
        const file = issue.fix.code.file;
        if (!grouped[file]) grouped[file] = [];
        grouped[file].push(issue);
      }
    }

    return grouped;
  }

  private async applyFixesToFile(
    octokit: Octokit,
    owner: string,
    repo: string,
    branch: string,
    filePath: string,
    issues: any[]
  ): Promise<void> {
    // Get current file content
    let fileContent = '';
    try {
      const { data } = await octokit.repos.getContent({
        owner,
        repo,
        path: filePath,
        ref: branch,
      });

      if ('content' in data) {
        fileContent = Buffer.from(data.content, 'base64').toString();
      }
    } catch (error) {
      // File doesn't exist, create it
      fileContent = '';
    }

    // Apply fixes
    let updatedContent = fileContent;
    for (const issue of issues) {
      if (issue.fix?.code) {
        updatedContent = this.applyFix(updatedContent, issue.fix.code);
      }
    }

    // Commit file
    await octokit.repos.createOrUpdateFileContents({
      owner,
      repo,
      path: filePath,
      message: `Fix: ${issues.map((i) => i.type).join(', ')} issues`,
      content: Buffer.from(updatedContent).toString('base64'),
      branch,
    });
  }

  private applyFix(content: string, fix: { before: string; after: string }): string {
    return content.replace(fix.before, fix.after);
  }

  private buildPRDescription(issues: any[]): string {
    let description = '## ðŸ’… Karen has spoken\n\n';
    description += `Found ${issues.length} layout issues that need fixing.\n\n`;

    const critical = issues.filter((i) => i.severity === 'critical');
    const high = issues.filter((i) => i.severity === 'high');
    const medium = issues.filter((i) => i.severity === 'medium');

    if (critical.length > 0) {
      description += `### ðŸš¨ Critical Issues (${critical.length})\n\n`;
      critical.forEach((i) => {
        description += `- **${i.type}**: ${i.message}\n`;
      });
      description += '\n';
    }

    if (high.length > 0) {
      description += `### âš ï¸ High Priority (${high.length})\n\n`;
      high.forEach((i) => {
        description += `- **${i.type}**: ${i.message}\n`;
      });
      description += '\n';
    }

    if (medium.length > 0) {
      description += `### ðŸ“‹ Medium Priority (${medium.length})\n\n`;
      medium.forEach((i) => {
        description += `- **${i.type}**: ${i.message}\n`;
      });
    }

    description += '\n---\n\n';
    description += 'âœ¨ This PR was automatically generated by Karen CLI';

    return description;
  }
}
